{"ast":null,"code":"import _objectWithoutPropertiesLoose from\"@babel/runtime/helpers/objectWithoutPropertiesLoose\";const _excluded=[\"colors\",\"locations\",\"startPoint\",\"endPoint\"];import*as React from'react';import View from\"react-native-web/dist/exports/View\";import{normalizeColor}from'./normalizeColor';import{jsx as _jsx}from\"react/jsx-runtime\";export default function NativeLinearGradient(_ref){let{colors,locations,startPoint,endPoint}=_ref,props=_objectWithoutPropertiesLoose(_ref,_excluded);const[{height,width},setLayout]=React.useState({height:1,width:1});const linearGradientBackgroundImage=React.useMemo(()=>{return getLinearGradientBackgroundImage(colors,locations,startPoint,endPoint,width,height);},[colors,locations,startPoint,endPoint,width,height]);return _jsx(View,Object.assign({},props,{style:[props.style,{backgroundImage:linearGradientBackgroundImage}],onLayout:event=>{const{width,height}=event.nativeEvent.layout;setLayout(oldLayout=>{if(width!==oldLayout.width||height!==oldLayout.height){return{height,width};}return oldLayout;});if(props.onLayout){props.onLayout(event);}}}));}export function getLinearGradientBackgroundImage(colors,locations,startPoint,endPoint,width=1,height=1){const gradientColors=calculateGradientColors(colors,locations);const angle=calculatePseudoAngle(width,height,startPoint,endPoint);return`linear-gradient(${angle}deg, ${gradientColors.join(', ')})`;}function calculatePseudoAngle(width,height,startPoint,endPoint){const getControlPoints=()=>{let correctedStartPoint=[0,0];if(Array.isArray(startPoint)){correctedStartPoint=[startPoint[0]!=null?startPoint[0]:0.0,startPoint[1]!=null?startPoint[1]:0.0];}let correctedEndPoint=[0.0,1.0];if(Array.isArray(endPoint)){correctedEndPoint=[endPoint[0]!=null?endPoint[0]:0.0,endPoint[1]!=null?endPoint[1]:1.0];}return[correctedStartPoint,correctedEndPoint];};const[start,end]=getControlPoints();start[0]*=width;end[0]*=width;start[1]*=height;end[1]*=height;const py=end[1]-start[1];const px=end[0]-start[0];return 90+Math.atan2(py,px)*180/Math.PI;}function calculateGradientColors(colors,locations){return colors.map((color,index)=>{const output=normalizeColor(color);if(locations&&locations[index]){const location=Math.max(0,Math.min(1,locations[index]));const percentage=location*100;return`${output} ${percentage}%`;}return output;});}","map":{"version":3,"names":["React","View","normalizeColor","jsx","_jsx","NativeLinearGradient","_ref","colors","locations","startPoint","endPoint","props","_objectWithoutPropertiesLoose","_excluded","height","width","setLayout","useState","linearGradientBackgroundImage","useMemo","getLinearGradientBackgroundImage","Object","assign","style","backgroundImage","onLayout","event","nativeEvent","layout","oldLayout","gradientColors","calculateGradientColors","angle","calculatePseudoAngle","join","getControlPoints","correctedStartPoint","Array","isArray","correctedEndPoint","start","end","py","px","Math","atan2","PI","map","color","index","output","location","max","min","percentage"],"sources":["/Users/nextek/Desktop/folder/SwiftPay/node_modules/expo-linear-gradient/src/NativeLinearGradient.web.tsx"],"sourcesContent":["import * as React from 'react';\nimport { View } from 'react-native';\n\nimport { NativeLinearGradientPoint, NativeLinearGradientProps } from './NativeLinearGradient.types';\nimport { normalizeColor } from './normalizeColor';\n\nexport default function NativeLinearGradient({\n  colors,\n  locations,\n  startPoint,\n  endPoint,\n  ...props\n}: NativeLinearGradientProps): React.ReactElement {\n  const [{ height, width }, setLayout] = React.useState({\n    height: 1,\n    width: 1,\n  });\n\n  // TODO(Bacon): In the future we could consider adding `backgroundRepeat: \"no-repeat\"`. For more\n  // browser support.\n  const linearGradientBackgroundImage = React.useMemo(() => {\n    return getLinearGradientBackgroundImage(colors, locations, startPoint, endPoint, width, height);\n  }, [colors, locations, startPoint, endPoint, width, height]);\n\n  return (\n    <View\n      {...props}\n      style={[\n        props.style,\n        // @ts-ignore: [ts] Property 'backgroundImage' does not exist on type 'ViewStyle'.\n        { backgroundImage: linearGradientBackgroundImage },\n      ]}\n      onLayout={(event) => {\n        const { width, height } = event.nativeEvent.layout;\n\n        setLayout((oldLayout) => {\n          // don't set new layout state unless the layout has actually changed\n          if (width !== oldLayout.width || height !== oldLayout.height) {\n            return { height, width };\n          }\n\n          return oldLayout;\n        });\n\n        if (props.onLayout) {\n          props.onLayout(event);\n        }\n      }}\n    />\n  );\n}\n\n/**\n * Extracted to a separate function in order to be able to test logic independently.\n */\nexport function getLinearGradientBackgroundImage(\n  colors: readonly number[] | string[],\n  locations?: readonly number[] | null,\n  startPoint?: NativeLinearGradientPoint | null,\n  endPoint?: NativeLinearGradientPoint | null,\n  width: number = 1,\n  height: number = 1\n) {\n  const gradientColors = calculateGradientColors(colors, locations);\n  const angle = calculatePseudoAngle(width, height, startPoint, endPoint);\n  return `linear-gradient(${angle}deg, ${gradientColors.join(', ')})`;\n}\n\nfunction calculatePseudoAngle(\n  width: number,\n  height: number,\n  startPoint?: NativeLinearGradientPoint | null,\n  endPoint?: NativeLinearGradientPoint | null\n) {\n  const getControlPoints = (): NativeLinearGradientPoint[] => {\n    let correctedStartPoint: NativeLinearGradientPoint = [0, 0];\n    if (Array.isArray(startPoint)) {\n      correctedStartPoint = [\n        startPoint[0] != null ? startPoint[0] : 0.0,\n        startPoint[1] != null ? startPoint[1] : 0.0,\n      ];\n    }\n    let correctedEndPoint: NativeLinearGradientPoint = [0.0, 1.0];\n    if (Array.isArray(endPoint)) {\n      correctedEndPoint = [\n        endPoint[0] != null ? endPoint[0] : 0.0,\n        endPoint[1] != null ? endPoint[1] : 1.0,\n      ];\n    }\n    return [correctedStartPoint, correctedEndPoint];\n  };\n\n  const [start, end] = getControlPoints();\n  start[0] *= width;\n  end[0] *= width;\n  start[1] *= height;\n  end[1] *= height;\n  const py = end[1] - start[1];\n  const px = end[0] - start[0];\n\n  return 90 + (Math.atan2(py, px) * 180) / Math.PI;\n}\n\nfunction calculateGradientColors(\n  colors: readonly number[] | string[],\n  locations?: readonly number[] | null\n) {\n  return colors.map((color: number | string, index: number): string | void => {\n    const output = normalizeColor(color);\n    if (locations && locations[index]) {\n      const location = Math.max(0, Math.min(1, locations[index]));\n      // Convert 0...1 to 0...100\n      const percentage = location * 100;\n      return `${output} ${percentage}%`;\n    }\n    return output;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}