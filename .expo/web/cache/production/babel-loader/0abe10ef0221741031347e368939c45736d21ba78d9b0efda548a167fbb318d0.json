{"ast":null,"code":"import React,{useContext,useEffect,useLayoutEffect,useMemo,useRef}from'react';import Platform from\"react-native-web/dist/exports/Platform\";import findNodeHandle from\"react-native-web/dist/exports/findNodeHandle\";import{isJestEnv}from'../../../utils';import GestureHandlerRootViewContext from'../../../GestureHandlerRootViewContext';import{useAnimatedGesture}from'./useAnimatedGesture';import{attachHandlers}from'./attachHandlers';import{needsToReattach}from'./needsToReattach';import{dropHandlers}from'./dropHandlers';import{useWebEventHandlers}from'./utils';import{Wrap,AnimatedWrap}from'./Wrap';import{useDetectorUpdater}from'./useDetectorUpdater';import{useViewRefHandler}from'./useViewRefHandler';function propagateDetectorConfig(props,gesture){const keysToPropagate=['userSelect','enableContextMenu','touchAction'];for(const key of keysToPropagate){const value=props[key];if(value===undefined){continue;}for(const g of gesture.toGestureArray()){const config=g.config;config[key]=value;}}}export const GestureDetector=props=>{const rootViewContext=useContext(GestureHandlerRootViewContext);if(false&&!rootViewContext&&!isJestEnv()&&false){throw new Error('GestureDetector must be used as a descendant of GestureHandlerRootView. Otherwise the gestures will not be recognized. See https://docs.swmansion.com/react-native-gesture-handler/docs/installation for more details.');}const gestureConfig=props.gesture;propagateDetectorConfig(props,gestureConfig);const gesturesToAttach=useMemo(()=>gestureConfig.toGestureArray(),[gestureConfig]);const shouldUseReanimated=gesturesToAttach.some(g=>g.shouldUseReanimated);const webEventHandlersRef=useWebEventHandlers();const state=useRef({firstRender:true,viewRef:null,previousViewTag:-1,forceRebuildReanimatedEvent:false}).current;const preparedGesture=React.useRef({attachedGestures:[],animatedEventHandler:null,animatedHandlers:null,shouldUseReanimated:shouldUseReanimated,isMounted:false}).current;const updateAttachedGestures=useDetectorUpdater(state,preparedGesture,gesturesToAttach,gestureConfig,webEventHandlersRef);const refHandler=useViewRefHandler(state,updateAttachedGestures);const needsToRebuildReanimatedEvent=state.firstRender||state.forceRebuildReanimatedEvent||needsToReattach(preparedGesture,gesturesToAttach);state.forceRebuildReanimatedEvent=false;useAnimatedGesture(preparedGesture,needsToRebuildReanimatedEvent);useLayoutEffect(()=>{const viewTag=findNodeHandle(state.viewRef);preparedGesture.isMounted=true;attachHandlers({preparedGesture,gestureConfig,gesturesToAttach,webEventHandlersRef,viewTag});return()=>{preparedGesture.isMounted=false;dropHandlers(preparedGesture);};},[]);useEffect(()=>{if(state.firstRender){state.firstRender=false;}else{updateAttachedGestures();}},[props]);if(shouldUseReanimated){return React.createElement(AnimatedWrap,{ref:refHandler,onGestureHandlerEvent:preparedGesture.animatedEventHandler},props.children);}else{return React.createElement(Wrap,{ref:refHandler},props.children);}};","map":{"version":3,"names":["React","useContext","useEffect","useLayoutEffect","useMemo","useRef","Platform","findNodeHandle","isJestEnv","GestureHandlerRootViewContext","useAnimatedGesture","attachHandlers","needsToReattach","dropHandlers","useWebEventHandlers","Wrap","AnimatedWrap","useDetectorUpdater","useViewRefHandler","propagateDetectorConfig","props","gesture","keysToPropagate","key","value","undefined","g","toGestureArray","config","GestureDetector","rootViewContext","Error","gestureConfig","gesturesToAttach","shouldUseReanimated","some","webEventHandlersRef","state","firstRender","viewRef","previousViewTag","forceRebuildReanimatedEvent","current","preparedGesture","attachedGestures","animatedEventHandler","animatedHandlers","isMounted","updateAttachedGestures","refHandler","needsToRebuildReanimatedEvent","viewTag","createElement","ref","onGestureHandlerEvent","children"],"sources":["/Users/nextek/Desktop/folder/SwiftPay/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector/index.tsx"],"sourcesContent":["/* eslint-disable react/no-unused-prop-types */\nimport React, {\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n} from 'react';\nimport { Platform, findNodeHandle } from 'react-native';\nimport { GestureType } from '../gesture';\nimport { UserSelect, TouchAction } from '../../gestureHandlerCommon';\nimport { ComposedGesture } from '../gestureComposition';\nimport { isJestEnv } from '../../../utils';\n\nimport GestureHandlerRootViewContext from '../../../GestureHandlerRootViewContext';\nimport { AttachedGestureState, GestureDetectorState } from './types';\nimport { useAnimatedGesture } from './useAnimatedGesture';\nimport { attachHandlers } from './attachHandlers';\nimport { needsToReattach } from './needsToReattach';\nimport { dropHandlers } from './dropHandlers';\nimport { useWebEventHandlers } from './utils';\nimport { Wrap, AnimatedWrap } from './Wrap';\nimport { useDetectorUpdater } from './useDetectorUpdater';\nimport { useViewRefHandler } from './useViewRefHandler';\n\nfunction propagateDetectorConfig(\n  props: GestureDetectorProps,\n  gesture: ComposedGesture | GestureType\n) {\n  const keysToPropagate: (keyof GestureDetectorProps)[] = [\n    'userSelect',\n    'enableContextMenu',\n    'touchAction',\n  ];\n\n  for (const key of keysToPropagate) {\n    const value = props[key];\n    if (value === undefined) {\n      continue;\n    }\n\n    for (const g of gesture.toGestureArray()) {\n      const config = g.config as { [key: string]: unknown };\n      config[key] = value;\n    }\n  }\n}\n\ninterface GestureDetectorProps {\n  children?: React.ReactNode;\n  /**\n   * A gesture object containing the configuration and callbacks.\n   * Can be any of:\n   * - base gestures (`Tap`, `Pan`, ...)\n   * - `ComposedGesture` (`Race`, `Simultaneous`, `Exclusive`)\n   */\n  gesture: ComposedGesture | GestureType;\n  /**\n   * #### Web only\n   * This parameter allows to specify which `userSelect` property should be applied to underlying view.\n   * Possible values are `\"none\" | \"auto\" | \"text\"`. Default value is set to `\"none\"`.\n   */\n  userSelect?: UserSelect;\n  /**\n   * #### Web only\n   * Specifies whether context menu should be enabled after clicking on underlying view with right mouse button.\n   * Default value is set to `false`.\n   */\n  enableContextMenu?: boolean;\n  /**\n   * #### Web only\n   * This parameter allows to specify which `touchAction` property should be applied to underlying view.\n   * Supports all CSS touch-action values (e.g. `\"none\"`, `\"pan-y\"`). Default value is set to `\"none\"`.\n   */\n  touchAction?: TouchAction;\n}\n\n/**\n * `GestureDetector` is responsible for creating and updating native gesture handlers based on the config of provided gesture.\n *\n * ### Props\n * - `gesture`\n * - `userSelect` (**Web only**)\n * - `enableContextMenu` (**Web only**)\n * - `touchAction` (**Web only**)\n *\n * ### Remarks\n * - Gesture Detector will use first native view in its subtree to recognize gestures, however if this view is used only to group its children it may get automatically collapsed.\n * - Using the same instance of a gesture across multiple Gesture Detectors is not possible.\n *\n * @see https://docs.swmansion.com/react-native-gesture-handler/docs/gestures/gesture-detector\n */\nexport const GestureDetector = (props: GestureDetectorProps) => {\n  const rootViewContext = useContext(GestureHandlerRootViewContext);\n  if (__DEV__ && !rootViewContext && !isJestEnv() && Platform.OS !== 'web') {\n    throw new Error(\n      'GestureDetector must be used as a descendant of GestureHandlerRootView. Otherwise the gestures will not be recognized. See https://docs.swmansion.com/react-native-gesture-handler/docs/installation for more details.'\n    );\n  }\n\n  // Gesture config should be wrapped with useMemo to prevent unnecessary re-renders\n  const gestureConfig = props.gesture;\n  propagateDetectorConfig(props, gestureConfig);\n\n  const gesturesToAttach = useMemo(\n    () => gestureConfig.toGestureArray(),\n    [gestureConfig]\n  );\n  const shouldUseReanimated = gesturesToAttach.some(\n    (g) => g.shouldUseReanimated\n  );\n\n  const webEventHandlersRef = useWebEventHandlers();\n  // Store state in ref to prevent unnecessary renders\n  const state = useRef<GestureDetectorState>({\n    firstRender: true,\n    viewRef: null,\n    previousViewTag: -1,\n    forceRebuildReanimatedEvent: false,\n  }).current;\n\n  const preparedGesture = React.useRef<AttachedGestureState>({\n    attachedGestures: [],\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    shouldUseReanimated: shouldUseReanimated,\n    isMounted: false,\n  }).current;\n\n  const updateAttachedGestures = useDetectorUpdater(\n    state,\n    preparedGesture,\n    gesturesToAttach,\n    gestureConfig,\n    webEventHandlersRef\n  );\n\n  const refHandler = useViewRefHandler(state, updateAttachedGestures);\n\n  // Reanimated event should be rebuilt only when gestures are reattached, otherwise\n  // config update will be enough as all necessary items are stored in shared values anyway\n  const needsToRebuildReanimatedEvent =\n    state.firstRender ||\n    state.forceRebuildReanimatedEvent ||\n    needsToReattach(preparedGesture, gesturesToAttach);\n  state.forceRebuildReanimatedEvent = false;\n\n  useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n\n  useLayoutEffect(() => {\n    const viewTag = findNodeHandle(state.viewRef) as number;\n    preparedGesture.isMounted = true;\n\n    attachHandlers({\n      preparedGesture,\n      gestureConfig,\n      gesturesToAttach,\n      webEventHandlersRef,\n      viewTag,\n    });\n\n    return () => {\n      preparedGesture.isMounted = false;\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (state.firstRender) {\n      state.firstRender = false;\n    } else {\n      updateAttachedGestures();\n    }\n  }, [props]);\n\n  if (shouldUseReanimated) {\n    return (\n      <AnimatedWrap\n        ref={refHandler}\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\n        {props.children}\n      </AnimatedWrap>\n    );\n  } else {\n    return <Wrap ref={refHandler}>{props.children}</Wrap>;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}