{"ast":null,"code":"'use strict';import{has}from\"./utils.js\";import{WorkletEventHandler}from\"../WorkletEventHandler.js\";import{findNodeHandle}from'../platformFunctions/findNodeHandle';export class NativeEventsManager{#managedComponent;#componentOptions;#eventViewTag=-1;constructor(component,options){this.#managedComponent=component;this.#componentOptions=options;this.#eventViewTag=this.getEventViewTag();}attachEvents(){executeForEachEventHandler(this.#managedComponent.props,(key,handler)=>{handler.registerForEvents(this.#eventViewTag,key);});}detachEvents(){executeForEachEventHandler(this.#managedComponent.props,(_key,handler)=>{handler.unregisterFromEvents(this.#eventViewTag);});}updateEvents(prevProps){const computedEventTag=this.getEventViewTag();if(this.#eventViewTag!==computedEventTag){executeForEachEventHandler(prevProps,(_key,handler)=>{handler.unregisterFromEvents(this.#eventViewTag);});this.#eventViewTag=computedEventTag;this.attachEvents();return;}executeForEachEventHandler(prevProps,(key,prevHandler)=>{const newProp=this.#managedComponent.props[key];if(!newProp){prevHandler.unregisterFromEvents(this.#eventViewTag);}else if(isWorkletEventHandler(newProp)&&newProp.workletEventHandler!==prevHandler){prevHandler.unregisterFromEvents(this.#eventViewTag);newProp.workletEventHandler.registerForEvents(this.#eventViewTag);}});executeForEachEventHandler(this.#managedComponent.props,(key,handler)=>{if(!prevProps[key]){handler.registerForEvents(this.#eventViewTag);}});}getEventViewTag(){const componentAnimatedRef=this.#managedComponent._component;let newTag;if(componentAnimatedRef.getScrollableNode){const scrollableNode=componentAnimatedRef.getScrollableNode();newTag=findNodeHandle(scrollableNode)??-1;}else{newTag=findNodeHandle(this.#componentOptions?.setNativeProps?this.#managedComponent:componentAnimatedRef)??-1;}return newTag;}}function isWorkletEventHandler(prop){return has('workletEventHandler',prop)&&prop.workletEventHandler instanceof WorkletEventHandler;}function executeForEachEventHandler(props,callback){for(const key in props){const prop=props[key];if(isWorkletEventHandler(prop)){callback(key,prop.workletEventHandler);}}}","map":{"version":3,"names":["has","WorkletEventHandler","findNodeHandle","NativeEventsManager","managedComponent","componentOptions","eventViewTag","constructor","component","options","getEventViewTag","attachEvents","executeForEachEventHandler","props","key","handler","registerForEvents","detachEvents","_key","unregisterFromEvents","updateEvents","prevProps","computedEventTag","prevHandler","newProp","isWorkletEventHandler","workletEventHandler","componentAnimatedRef","_component","newTag","getScrollableNode","scrollableNode","setNativeProps","prop","callback"],"sources":["/Users/nextek/Desktop/folder/SwiftPay/node_modules/react-native-reanimated/src/createAnimatedComponent/NativeEventsManager.ts"],"sourcesContent":["'use strict';\nimport type {\n  INativeEventsManager,\n  IAnimatedComponentInternal,\n  AnimatedComponentProps,\n  InitialComponentProps,\n  AnimatedComponentRef,\n} from './commonTypes';\nimport { has } from './utils';\nimport { WorkletEventHandler } from '../WorkletEventHandler';\nimport { findNodeHandle } from '../platformFunctions/findNodeHandle';\n\nexport class NativeEventsManager implements INativeEventsManager {\n  readonly #managedComponent: ManagedAnimatedComponent;\n  readonly #componentOptions?: ComponentOptions;\n  #eventViewTag = -1;\n\n  constructor(component: ManagedAnimatedComponent, options?: ComponentOptions) {\n    this.#managedComponent = component;\n    this.#componentOptions = options;\n    this.#eventViewTag = this.getEventViewTag();\n  }\n\n  public attachEvents() {\n    executeForEachEventHandler(this.#managedComponent.props, (key, handler) => {\n      handler.registerForEvents(this.#eventViewTag, key);\n    });\n  }\n\n  public detachEvents() {\n    executeForEachEventHandler(\n      this.#managedComponent.props,\n      (_key, handler) => {\n        handler.unregisterFromEvents(this.#eventViewTag);\n      }\n    );\n  }\n\n  public updateEvents(\n    prevProps: AnimatedComponentProps<InitialComponentProps>\n  ) {\n    const computedEventTag = this.getEventViewTag();\n    // If the event view tag changes, we need to completely re-mount all events\n    if (this.#eventViewTag !== computedEventTag) {\n      // Remove all bindings from previous props that ran on the old viewTag\n      executeForEachEventHandler(prevProps, (_key, handler) => {\n        handler.unregisterFromEvents(this.#eventViewTag);\n      });\n      // We don't need to unregister from current (new) props, because their events weren't registered yet\n      // Replace the view tag\n      this.#eventViewTag = computedEventTag;\n      // Attach the events with a new viewTag\n      this.attachEvents();\n      return;\n    }\n\n    executeForEachEventHandler(prevProps, (key, prevHandler) => {\n      const newProp = this.#managedComponent.props[key];\n      if (!newProp) {\n        // Prop got deleted\n        prevHandler.unregisterFromEvents(this.#eventViewTag);\n      } else if (\n        isWorkletEventHandler(newProp) &&\n        newProp.workletEventHandler !== prevHandler\n      ) {\n        // Prop got changed\n        prevHandler.unregisterFromEvents(this.#eventViewTag);\n        newProp.workletEventHandler.registerForEvents(this.#eventViewTag);\n      }\n    });\n\n    executeForEachEventHandler(this.#managedComponent.props, (key, handler) => {\n      if (!prevProps[key]) {\n        // Prop got added\n        handler.registerForEvents(this.#eventViewTag);\n      }\n    });\n  }\n\n  private getEventViewTag() {\n    // Get the tag for registering events - since the event emitting view can be nested inside the main component\n    const componentAnimatedRef = this.#managedComponent\n      ._component as AnimatedComponentRef;\n    let newTag: number;\n    if (componentAnimatedRef.getScrollableNode) {\n      const scrollableNode = componentAnimatedRef.getScrollableNode();\n      newTag = findNodeHandle(scrollableNode) ?? -1;\n    } else {\n      newTag =\n        findNodeHandle(\n          this.#componentOptions?.setNativeProps\n            ? this.#managedComponent\n            : componentAnimatedRef\n        ) ?? -1;\n    }\n    return newTag;\n  }\n}\n\nfunction isWorkletEventHandler(\n  prop: unknown\n): prop is WorkletEventHandlerHolder {\n  return (\n    has('workletEventHandler', prop) &&\n    prop.workletEventHandler instanceof WorkletEventHandler\n  );\n}\n\nfunction executeForEachEventHandler(\n  props: AnimatedComponentProps<InitialComponentProps>,\n  callback: (\n    key: string,\n    handler: InstanceType<typeof WorkletEventHandler>\n  ) => void\n) {\n  for (const key in props) {\n    const prop = props[key];\n    if (isWorkletEventHandler(prop)) {\n      callback(key, prop.workletEventHandler);\n    }\n  }\n}\n\ntype ManagedAnimatedComponent = React.Component<\n  AnimatedComponentProps<InitialComponentProps>\n> &\n  IAnimatedComponentInternal;\n\ntype ComponentOptions = {\n  setNativeProps: (\n    ref: AnimatedComponentRef,\n    props: InitialComponentProps\n  ) => void;\n};\n\ntype WorkletEventHandlerHolder = {\n  workletEventHandler: InstanceType<typeof WorkletEventHandler>;\n};\n"],"mappings":"AAAA,YAAY,CAQZ,OAASA,GAAG,KAAQ,YAAS,CAC7B,OAASC,mBAAmB,KAAQ,2BAAwB,CAC5D,OAASC,cAAc,KAAQ,qCAAqC,CAEpE,MAAO,MAAM,CAAAC,mBAAoD,CACtD,CAACC,gBAAgB,CACjB,CAACC,gBAAgB,CAC1B,CAACC,YAAY,CAAG,CAAC,CAAC,CAElBC,WAAWA,CAACC,SAAmC,CAAEC,OAA0B,CAAE,CAC3E,IAAI,CAAC,CAACL,gBAAgB,CAAGI,SAAS,CAClC,IAAI,CAAC,CAACH,gBAAgB,CAAGI,OAAO,CAChC,IAAI,CAAC,CAACH,YAAY,CAAG,IAAI,CAACI,eAAe,CAAC,CAAC,CAC7C,CAEOC,YAAYA,CAAA,CAAG,CACpBC,0BAA0B,CAAC,IAAI,CAAC,CAACR,gBAAgB,CAACS,KAAK,CAAE,CAACC,GAAG,CAAEC,OAAO,GAAK,CACzEA,OAAO,CAACC,iBAAiB,CAAC,IAAI,CAAC,CAACV,YAAY,CAAEQ,GAAG,CAAC,CACpD,CAAC,CAAC,CACJ,CAEOG,YAAYA,CAAA,CAAG,CACpBL,0BAA0B,CACxB,IAAI,CAAC,CAACR,gBAAgB,CAACS,KAAK,CAC5B,CAACK,IAAI,CAAEH,OAAO,GAAK,CACjBA,OAAO,CAACI,oBAAoB,CAAC,IAAI,CAAC,CAACb,YAAY,CAAC,CAClD,CACF,CAAC,CACH,CAEOc,YAAYA,CACjBC,SAAwD,CACxD,CACA,KAAM,CAAAC,gBAAgB,CAAG,IAAI,CAACZ,eAAe,CAAC,CAAC,CAE/C,GAAI,IAAI,CAAC,CAACJ,YAAY,GAAKgB,gBAAgB,CAAE,CAE3CV,0BAA0B,CAACS,SAAS,CAAE,CAACH,IAAI,CAAEH,OAAO,GAAK,CACvDA,OAAO,CAACI,oBAAoB,CAAC,IAAI,CAAC,CAACb,YAAY,CAAC,CAClD,CAAC,CAAC,CAGF,IAAI,CAAC,CAACA,YAAY,CAAGgB,gBAAgB,CAErC,IAAI,CAACX,YAAY,CAAC,CAAC,CACnB,OACF,CAEAC,0BAA0B,CAACS,SAAS,CAAE,CAACP,GAAG,CAAES,WAAW,GAAK,CAC1D,KAAM,CAAAC,OAAO,CAAG,IAAI,CAAC,CAACpB,gBAAgB,CAACS,KAAK,CAACC,GAAG,CAAC,CACjD,GAAI,CAACU,OAAO,CAAE,CAEZD,WAAW,CAACJ,oBAAoB,CAAC,IAAI,CAAC,CAACb,YAAY,CAAC,CACtD,CAAC,IAAM,IACLmB,qBAAqB,CAACD,OAAO,CAAC,EAC9BA,OAAO,CAACE,mBAAmB,GAAKH,WAAW,CAC3C,CAEAA,WAAW,CAACJ,oBAAoB,CAAC,IAAI,CAAC,CAACb,YAAY,CAAC,CACpDkB,OAAO,CAACE,mBAAmB,CAACV,iBAAiB,CAAC,IAAI,CAAC,CAACV,YAAY,CAAC,CACnE,CACF,CAAC,CAAC,CAEFM,0BAA0B,CAAC,IAAI,CAAC,CAACR,gBAAgB,CAACS,KAAK,CAAE,CAACC,GAAG,CAAEC,OAAO,GAAK,CACzE,GAAI,CAACM,SAAS,CAACP,GAAG,CAAC,CAAE,CAEnBC,OAAO,CAACC,iBAAiB,CAAC,IAAI,CAAC,CAACV,YAAY,CAAC,CAC/C,CACF,CAAC,CAAC,CACJ,CAEQI,eAAeA,CAAA,CAAG,CAExB,KAAM,CAAAiB,oBAAoB,CAAG,IAAI,CAAC,CAACvB,gBAAgB,CAChDwB,UAAkC,CACrC,GAAI,CAAAC,MAAc,CAClB,GAAIF,oBAAoB,CAACG,iBAAiB,CAAE,CAC1C,KAAM,CAAAC,cAAc,CAAGJ,oBAAoB,CAACG,iBAAiB,CAAC,CAAC,CAC/DD,MAAM,CAAG3B,cAAc,CAAC6B,cAAc,CAAC,EAAI,CAAC,CAAC,CAC/C,CAAC,IAAM,CACLF,MAAM,CACJ3B,cAAc,CACZ,IAAI,CAAC,CAACG,gBAAgB,EAAE2B,cAAc,CAClC,IAAI,CAAC,CAAC5B,gBAAgB,CACtBuB,oBACN,CAAC,EAAI,CAAC,CAAC,CACX,CACA,MAAO,CAAAE,MAAM,CACf,CACF,CAEA,QAAS,CAAAJ,qBAAqBA,CAC5BQ,IAAa,CACsB,CACnC,MACE,CAAAjC,GAAG,CAAC,qBAAqB,CAAEiC,IAAI,CAAC,EAChCA,IAAI,CAACP,mBAAmB,WAAY,CAAAzB,mBAAmB,CAE3D,CAEA,QAAS,CAAAW,0BAA0BA,CACjCC,KAAoD,CACpDqB,QAGS,CACT,CACA,IAAK,KAAM,CAAApB,GAAG,GAAI,CAAAD,KAAK,CAAE,CACvB,KAAM,CAAAoB,IAAI,CAAGpB,KAAK,CAACC,GAAG,CAAC,CACvB,GAAIW,qBAAqB,CAACQ,IAAI,CAAC,CAAE,CAC/BC,QAAQ,CAACpB,GAAG,CAAEmB,IAAI,CAACP,mBAAmB,CAAC,CACzC,CACF,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}