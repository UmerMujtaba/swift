{"ast":null,"code":"import{registerHandler}from'../../handlersRegistry';import RNGestureHandlerModule from'../../../RNGestureHandlerModule';import{filterConfig,scheduleFlushOperations}from'../../utils';import{ActionType}from'../../../ActionType';import Platform from\"react-native-web/dist/exports/Platform\";import{ghQueueMicrotask}from'../../../ghQueueMicrotask';import{extractGestureRelations,checkGestureCallbacksForWorklets,ALLOWED_PROPS}from'./utils';export function attachHandlers({preparedGesture,gestureConfig,gesturesToAttach,viewTag,webEventHandlersRef}){gestureConfig.initialize();ghQueueMicrotask(()=>{if(!preparedGesture.isMounted){return;}gestureConfig.prepare();});for(const handler of gesturesToAttach){checkGestureCallbacksForWorklets(handler);RNGestureHandlerModule.createGestureHandler(handler.handlerName,handler.handlerTag,filterConfig(handler.config,ALLOWED_PROPS));registerHandler(handler.handlerTag,handler,handler.config.testId);}ghQueueMicrotask(()=>{if(!preparedGesture.isMounted){return;}for(const handler of gesturesToAttach){RNGestureHandlerModule.updateGestureHandler(handler.handlerTag,filterConfig(handler.config,ALLOWED_PROPS,extractGestureRelations(handler)));}scheduleFlushOperations();});for(const gesture of gesturesToAttach){const actionType=gesture.shouldUseReanimated?ActionType.REANIMATED_WORKLET:ActionType.JS_FUNCTION_NEW_API;if(true){RNGestureHandlerModule.attachGestureHandler(gesture.handlerTag,viewTag,ActionType.JS_FUNCTION_OLD_API,webEventHandlersRef);}else{RNGestureHandlerModule.attachGestureHandler(gesture.handlerTag,viewTag,actionType);}}preparedGesture.attachedGestures=gesturesToAttach;if(preparedGesture.animatedHandlers){const isAnimatedGesture=g=>g.shouldUseReanimated;preparedGesture.animatedHandlers.value=gesturesToAttach.filter(isAnimatedGesture).map(g=>g.handlers);}}","map":{"version":3,"names":["registerHandler","RNGestureHandlerModule","filterConfig","scheduleFlushOperations","ActionType","Platform","ghQueueMicrotask","extractGestureRelations","checkGestureCallbacksForWorklets","ALLOWED_PROPS","attachHandlers","preparedGesture","gestureConfig","gesturesToAttach","viewTag","webEventHandlersRef","initialize","isMounted","prepare","handler","createGestureHandler","handlerName","handlerTag","config","testId","updateGestureHandler","gesture","actionType","shouldUseReanimated","REANIMATED_WORKLET","JS_FUNCTION_NEW_API","attachGestureHandler","JS_FUNCTION_OLD_API","attachedGestures","animatedHandlers","isAnimatedGesture","g","value","filter","map","handlers"],"sources":["/Users/nextek/Desktop/folder/SwiftPay/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector/attachHandlers.ts"],"sourcesContent":["import React from 'react';\nimport { GestureType, HandlerCallbacks } from '../gesture';\nimport { registerHandler } from '../../handlersRegistry';\nimport RNGestureHandlerModule from '../../../RNGestureHandlerModule';\nimport { filterConfig, scheduleFlushOperations } from '../../utils';\nimport { ComposedGesture } from '../gestureComposition';\nimport { ActionType } from '../../../ActionType';\nimport { Platform } from 'react-native';\nimport type RNGestureHandlerModuleWeb from '../../../RNGestureHandlerModule.web';\nimport { ghQueueMicrotask } from '../../../ghQueueMicrotask';\nimport { AttachedGestureState, WebEventHandler } from './types';\nimport {\n  extractGestureRelations,\n  checkGestureCallbacksForWorklets,\n  ALLOWED_PROPS,\n} from './utils';\n\ninterface AttachHandlersConfig {\n  preparedGesture: AttachedGestureState;\n  gestureConfig: ComposedGesture | GestureType;\n  gesturesToAttach: GestureType[];\n  viewTag: number;\n  webEventHandlersRef: React.RefObject<WebEventHandler>;\n}\n\nexport function attachHandlers({\n  preparedGesture,\n  gestureConfig,\n  gesturesToAttach,\n  viewTag,\n  webEventHandlersRef,\n}: AttachHandlersConfig) {\n  gestureConfig.initialize();\n\n  // Use queueMicrotask to extract handlerTags, because all refs should be initialized\n  // when it's ran\n  ghQueueMicrotask(() => {\n    if (!preparedGesture.isMounted) {\n      return;\n    }\n    gestureConfig.prepare();\n  });\n\n  for (const handler of gesturesToAttach) {\n    checkGestureCallbacksForWorklets(handler);\n    RNGestureHandlerModule.createGestureHandler(\n      handler.handlerName,\n      handler.handlerTag,\n      filterConfig(handler.config, ALLOWED_PROPS)\n    );\n\n    registerHandler(handler.handlerTag, handler, handler.config.testId);\n  }\n\n  // Use queueMicrotask to extract handlerTags, because all refs should be initialized\n  // when it's ran\n  ghQueueMicrotask(() => {\n    if (!preparedGesture.isMounted) {\n      return;\n    }\n    for (const handler of gesturesToAttach) {\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(\n          handler.config,\n          ALLOWED_PROPS,\n          extractGestureRelations(handler)\n        )\n      );\n    }\n\n    scheduleFlushOperations();\n  });\n\n  for (const gesture of gesturesToAttach) {\n    const actionType = gesture.shouldUseReanimated\n      ? ActionType.REANIMATED_WORKLET\n      : ActionType.JS_FUNCTION_NEW_API;\n\n    if (Platform.OS === 'web') {\n      (\n        RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler\n      )(\n        gesture.handlerTag,\n        viewTag,\n        ActionType.JS_FUNCTION_OLD_API, // Ignored on web\n        webEventHandlersRef\n      );\n    } else {\n      RNGestureHandlerModule.attachGestureHandler(\n        gesture.handlerTag,\n        viewTag,\n        actionType\n      );\n    }\n  }\n\n  preparedGesture.attachedGestures = gesturesToAttach;\n\n  if (preparedGesture.animatedHandlers) {\n    const isAnimatedGesture = (g: GestureType) => g.shouldUseReanimated;\n\n    preparedGesture.animatedHandlers.value = gesturesToAttach\n      .filter(isAnimatedGesture)\n      .map((g) => g.handlers) as unknown as HandlerCallbacks<\n      Record<string, unknown>\n    >[];\n  }\n}\n"],"mappings":"AAEA,OAASA,eAAT,KAAgC,wBAAhC,CACA,MAAO,CAAAC,sBAAP,KAAmC,iCAAnC,CACA,OAASC,YAAT,CAAuBC,uBAAvB,KAAsD,aAAtD,CAEA,OAASC,UAAT,KAA2B,qBAA3B,QAAAC,QAAA,8CAGA,OAASC,gBAAT,KAAiC,2BAAjC,CAEA,OACEC,uBADF,CAEEC,gCAFF,CAGEC,aAHF,KAIO,SAJP,CAcA,MAAO,SAAS,CAAAC,cAATA,CAAwB,CAC7BC,eAD6B,CAE7BC,aAF6B,CAG7BC,gBAH6B,CAI7BC,OAJ6B,CAK7BC,mBAL6B,CAAxB,CAMkB,CACvBH,aAAa,CAACI,UAAd,GAIAV,gBAAgB,CAAC,IAAM,CACrB,GAAI,CAACK,eAAe,CAACM,SAArB,CAAgC,CAC9B,OACD,CACDL,aAAa,CAACM,OAAd,GACD,CALe,CAAhB,CAOA,IAAK,KAAM,CAAAC,OAAX,GAAsB,CAAAN,gBAAtB,CAAwC,CACtCL,gCAAgC,CAACW,OAAD,CAAhC,CACAlB,sBAAsB,CAACmB,oBAAvB,CACED,OAAO,CAACE,WADV,CAEEF,OAAO,CAACG,UAFV,CAGEpB,YAAY,CAACiB,OAAO,CAACI,MAAT,CAAiBd,aAAjB,CAHd,EAMAT,eAAe,CAACmB,OAAO,CAACG,UAAT,CAAqBH,OAArB,CAA8BA,OAAO,CAACI,MAAR,CAAeC,MAA7C,CAAf,CACD,CAIDlB,gBAAgB,CAAC,IAAM,CACrB,GAAI,CAACK,eAAe,CAACM,SAArB,CAAgC,CAC9B,OACD,CACD,IAAK,KAAM,CAAAE,OAAX,GAAsB,CAAAN,gBAAtB,CAAwC,CACtCZ,sBAAsB,CAACwB,oBAAvB,CACEN,OAAO,CAACG,UADV,CAEEpB,YAAY,CACViB,OAAO,CAACI,MADE,CAEVd,aAFU,CAGVF,uBAAuB,CAACY,OAAD,CAHb,CAFd,EAQD,CAEDhB,uBAAuB,GACxB,CAhBe,CAAhB,CAkBA,IAAK,KAAM,CAAAuB,OAAX,GAAsB,CAAAb,gBAAtB,CAAwC,CACtC,KAAM,CAAAc,UAAU,CAAGD,OAAO,CAACE,mBAAR,CACfxB,UAAU,CAACyB,kBADI,CAEfzB,UAAU,CAAC0B,mBAFf,CAIA,QAA2B,CAEvB7B,sBAAsB,CAAC8B,oBADzB,CAGEL,OAAO,CAACJ,UAHV,CAIER,OAJF,CAKEV,UAAU,CAAC4B,mBALb,CAMEjB,mBANF,EAQD,CATD,IASO,CACLd,sBAAsB,CAAC8B,oBAAvB,CACEL,OAAO,CAACJ,UADV,CAEER,OAFF,CAGEa,UAHF,EAKD,CACF,CAEDhB,eAAe,CAACsB,gBAAhB,CAAmCpB,gBAAnC,CAEA,GAAIF,eAAe,CAACuB,gBAApB,CAAsC,CACpC,KAAM,CAAAC,iBAAiB,CAAIC,CAAD,EAAoBA,CAAC,CAACR,mBAAhD,CAEAjB,eAAe,CAACuB,gBAAhB,CAAiCG,KAAjC,CAAyCxB,gBAAgB,CACtDyB,MADsC,CAC/BH,iBAD+B,EAEtCI,GAFsC,CAEjCH,CAAD,EAAOA,CAAC,CAACI,QAFyB,CAAzC,CAKD,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}